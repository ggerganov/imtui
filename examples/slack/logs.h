#pragma once

#include <string>
#include <vector>

struct Log {
    std::string username;
    std::string text;
};

const std::vector<Log> kLogs = {
    { "dirbaio[m]", R"foo(oh lol and the proxy forwards the logs)foo" },
    { "jschievink", R"foo(yeah, that part works surprisingly well)foo" },
    { "dirbaio[m]", R"foo(ü§Ø)foo" },
    { "jschievink", R"foo(hat way users don't have to wait for me to copy the logs over)foo" },
    { "therealprof[m]", R"foo(Any chance to get a signoff on the newsletter?)foo" },
    { "dirbaio[m]", R"foo(it's somewhat crazy rube-goldberg-esque üòÇ)foo" },
    { "jschievink", R"foo(yeah)foo" },
    { "jschievink", R"foo(I'm kinda hoping the blog post makes github engineers terrified of me and fix the runner security issues by themselves)foo" },
    { "dirbaio[m]", R"foo(hahahaha)foo" },
    { "jschievink", R"foo(hen we won't need hacks like this)foo" },
    { "dirbaio[m]", R"foo(he runner code is huuuuge, have fun securing tha)foo" },
    { "jschievink", R"foo(hey just need to integrate the small patches rust-lang/rust uses)foo" },
    { "jschievink", R"foo(mostly the ability to filter events to not have it run on pull_request events)foo" },
    { "dirbaio[m]", R"foo(but what if I do want it to run on PRs?)foo" },
    { "dirbaio[m]", R"foo(if it can be properly secured, it's nice that someone can send a PR and get their stuff tested instantly without waiting for any approval)foo" },
    { "jschievink", R"foo(you want to grant arbitrary access to hardware?)foo" },
    { "dirbaio[m]", R"foo(what's the worst someone could do?)foo" },
    { "jschievink", R"foo(brick it, presumably)foo" },
    { "dirbaio[m]", R"foo(is it common to be able to brick chips?)foo" },
    { "jschievink", R"foo(I would assume so, yeah)foo" },
    { "jschievink", R"foo(many chips can disable SWD access)foo" },
    { "dirbaio[m]", R"foo(on nrfs you can enable APPROTECT (disables swd debugging) but you can always do the recover operation to erase and unlock the chip)foo" },
    { "jschievink", R"foo(you can also short out pins)foo" },
    { "jschievink", R"foo(depending on the current the chip can source/sink through GPIOs that might destroy it fairly quickly)foo" },
    { "jschievink", R"foo(requires you to mess with alternate functions and such, but you can do it even with no pins physically connected)foo" },
    { "dirbaio[m]", R"foo(uh what? you can enable 2 functions on the same pin, then get one to outputlow and the other high at the same time?)foo" },
    { "jschievink", R"foo(if you do want the runner to run on PRs then I think some sort of ephemeral VM setup like rust-lang uses would be appropriate)foo" },
    { "dirbaio[m]", R"foo(I was thinking of containers..)foo" },
    { "jschievink", R"foo(hmm, can you not short them out that way? I suppose there might only be one driver per pin...)foo" },
    { "dirbaio[m]", R"foo(no idea)foo" },
    { "jschievink", R"foo(containers could also work, but I haven't even figured out how to run the thing as non-roo)foo" },
    { "dirbaio[m]", R"foo(but that sounds strange coming from the nrf)foo" },
    { "dirbaio[m]", R"foo(containers are not secure)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party containers are not as secure)foo" },
    { "dirbaio[m]", R"foo(but super fast to start up)foo" },
    { "jschievink", R"foo(certainly that STM32 that just has multiple pads bonded to the same pin can be shorted out like tha)foo" },
    { "dirbaio[m]", R"foo(and no one's going to burn a kernel 0day on hacking some oss project's ci for the lulz)foo" },
    { "jschievink", R"foo(I'm currently using this docker image, but it doesn't work rootless: https://hub.docker.com/r/myoung34/github-runner)foo" },
    { "dirbaio[m]", R"foo(root inside a container is not considered dangerous)foo" },
    { "dirbaio[m]", R"foo(what's dangerous is if the container has --privileged)foo" },
    { "jschievink", R"foo(is that not equivalent to root outside the container anymore?)foo" },
    { "dirbaio[m]", R"foo(anymore? since when has i)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party anymore? when has it been?)foo" },
    { "dirbaio[m]", R"foo(what CMakeLists.txt dangerous is mounting `-v /var/run/docker.sock:/var/run/docker.sock`)foo" },
    { "dirbaio[m]", R"foo(access to docker.sock is equivalent to root on the host hehe)foo" },
    { "jschievink", R"foo(hmm, I thought it was dangerous in general)foo" },
    { "jschievink", R"foo(apparently my container knowledge is grossly outdated and/or wrong)foo" },
    { "dirbaio[m]", R"foo(ideally the runner would run on the hos)foo" },
    { "dirbaio[m]", R"foo(and spawn an ephemeral container per job)foo" },
    { "dirbaio[m]", R"foo(if you run the runner inside docker it doesn't gain you much security anyway)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party if you run the runner inside the container it doesn't gain you much security anyway)foo" },
    { "dirbaio[m]", R"foo(because for example malicious job can steal your runner's credentials)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party because for example a malicious job can steal your runner's credentials)foo" },
    { "jschievink", R"foo(it does also spawn containers to run the actions in)foo" },
    { "dirbaio[m]", R"foo(but isn't that opt-in?)foo" },
    { "jschievink", R"foo(hmm, is it? I thought no)foo" },
    { "jschievink", R"foo(ah, maybe jobs that just run a command are ran as-is)foo" },
    { "dirbaio[m]", R"foo(https://github.com/akiles/embassy/runs/1914993978?check_suite_focus=true)foo" },
    { "dirbaio[m]", R"foo(yeah, `run: echo lol` simply... gets run :D)foo" },
    { "dirbaio[m]", R"foo(no ocker)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party no docker)foo" },
    { "dirbaio[m]", R"foo(RCE vuln as a service üëå)foo" },
    { "agg", R"foo(i wouldn't be surprised if github did notice you)foo" },
    { "agg", R"foo(hey actively look for CI stuff)foo" },
    { "agg", R"foo(https://securitylab.github.com/advisories/GHSL-2020-244-nonebot-nonebot2-workflow)foo" },
    { "agg", R"foo(I think what they actually do is search for every workflow using 'pull_request_target', pre-emptively open a security issue, and then double check it's definitely vulnerable)foo" },
    { "jschievink", R"foo(oh, cool)foo" },
    { "jschievink", R"foo(yeah maybe they automatically flag users for a deeper audi)foo" },
    { "agg", R"foo(yea, I think pull_request_target is quite a volatile footgun)foo" },
    { "dirbaio[m]", R"foo(hm, bu)foo" },
    { "dirbaio[m]", R"foo(so the actions (steps with `uses: blah`) run sandboxed separately from steps with `run: blah`?)foo" },
    { "jschievink", R"foo(I thought so, but the more I look into this the less I understand i)foo" },
    { "dirbaio[m]", R"foo(so if you give your github token to one of these actions, it's still supposed to be safe from evil code?)foo" },
    { "jschievink", R"foo(maybe I just made that up for some reason)foo" },
    { "jschievink", R"foo(I read something about nested containers though)foo" },
    { "dirbaio[m]", R"foo(welp that must be the special sauce in their cloud runners)foo" },
    { "dirbaio[m]", R"foo(selfhosted runners is "just run shit on the host yolo")foo" },
    { "jschievink", R"foo(he cloud runners run in ephemeral VMs from what I know)foo" },
    { "agg", R"foo(I don't believe actions run separately to plain run: steps)foo" },
    { "agg", R"foo(or at least, they share the same filesystem?)foo" },
    { "dirbaio[m]", R"foo(yea they do)foo" },
    { "dirbaio[m]", R"foo(hat's why I don't get what the vuln is)foo" },
    { "jschievink", R"foo(maybe I was thinking of gitlab? where you do actually specify a docker image)foo" },
    { "jschievink", R"foo(not sure anymore :D)foo" },
    { "agg", R"foo(gitlab's ci seems much more sane and amenable to these things)foo" },
    { "dirbaio[m]", R"foo(yeah on gitlab you do specify image for steps)foo" },
    { "agg", R"foo(which vuln?)foo" },
    { "agg", R"foo(the one I linked?)foo" },
    { "dirbaio[m]", R"foo(yeah)foo" },
    { "agg", R"foo(anyone who opens a PR can run arbitrary code in your CI)foo" },
    { "dirbaio[m]", R"foo(like)foo" },
    { "agg", R"foo(including leaking your secrets)foo" },
    { "agg", R"foo(which they can then use to impersonate your.. github account?)foo" },
    { "agg", R"foo(or the github repo anyway)foo" },
    { "dirbaio[m]", R"foo(yeah, but why can't they do that writing custom `run: ` steps anyway?)foo" },
    { "agg", R"foo(it wouldn't get run)foo" },
    { "dirbaio[m]", R"foo(why)foo" },
    { "agg", R"foo(github does not typically execute workflow code from a pull reques)foo" },
    { "agg", R"foo(uh)foo" },
    { "agg", R"foo(in an environment with secrets, I mean)foo" },
    { "jschievink", R"foo(`pull_request` triggers do not get any secrets)foo" },
    { "agg", R"foo(when a PR triggers a CI run, no secrets are available to that CI execution)foo" },
    { "jschievink", R"foo(and also no privileged `GITHUB_TOKEN`)foo" },
    { "agg", R"foo(when using pull_request_target instead, the secrets are available, but it uses the PR's _base_ branch to load the workflow)foo" },
    { "agg", R"foo((and ignores the PR's workflow files))foo" },
    { "dirbaio[m]", R"foo(okay so `run: ` stuff runs with no secrets, but that `nonebot` action does run with secrets?)foo" },
    { "jschievink", R"foo(whether you have or don't have secrets is a property of the whole workflow run)foo" },
    { "jschievink", R"foo(either all steps and jobs have them, or none do)foo" },
    { "agg", R"foo(yea)foo" },
    { "agg", R"foo(and for a normal pull_request, no secrets but the PR's workflow file is run, for a pull_request_target, you get secrets, and use the repo's existing workflow)foo" },
    { "agg", R"foo(he vuln is that the PR could include content that caused the repo's existing workflow to run arb code)foo" },
    { "dirbaio[m]", R"foo(I see, so it's not for testing code in the PR)foo" },
    { "dirbaio[m]", R"foo(it's for doing automation shit like labeling and assigning people)foo" },
    { "dirbaio[m]", R"foo(and it runs with the yaml and code from master)foo" },
    { "agg", R"foo(yea)foo" },
    { "agg", R"foo(e.g. in stm32-rs I use it to push to the mmaps repo and add a comment with a link)foo" },
    { "dirbaio[m]", R"foo(and the vuln is that action running from master is explicitly checking out the pr's code and running i)foo" },
    { "agg", R"foo(but pushing to that repo requires a secret (a repo key) and leaving a comment requires GITHUB_TOKEN)foo" },
    { "dirbaio[m]", R"foo(yeaaaah)foo" },
    { "dirbaio[m]", R"foo(makes sense)foo" },
    { "agg", R"foo(yea)foo" },
    { "agg", R"foo(github recommend you do not check out the PR's code, ideally)foo" },
    { "agg", R"foo(but if you do check it out, don't run code from i)foo" },
    { "agg", R"foo(hey suggest you use the PR's CI to trigger a second CI job that runs in the repo context instead of using pull_request_target, but it's not clear to me how much that helps really)foo" },
    { "agg", R"foo(a bit, maybe)foo" },
    { "agg", R"foo(if your CI ultimately involves like, building the submitted PR, it's probably game over)foo" },
    { "agg", R"foo(in stm32-rs I pull in the inert yaml from the PR, svdtools uses yaml.safe_load to avoid that hilarity, so unless you can get code execution from a yaml file it should be ok, bu)foo" },
    { "agg", R"foo(you probably can get code execution from yaml, lol, yaml's a mess)foo" },
    { "agg", R"foo(originally it also happened to copy extract.sh which unzips the vendor svd zip files, which would have also been game over if some PR added lols to extract.sh)foo" },
    { "dirbaio[m]", R"foo(heheeee üòà)foo" },
    { "agg", R"foo(very 'sausage factory', don't look too close)foo" },
    { "dirbaio[m]", R"foo(microsoft loves their uuids üò§)foo" },
    { "agg", R"foo(i wonder if you could use 'bors try' to make it work ok)foo" },
    { "agg", R"foo(bors is able to push to the trying branch, you can have a CI workflow on push:trying which would get secrets)foo" },
    { "agg", R"foo(only authorised users can trigger 'bors try')foo" },
    { "agg", R"foo(anyway doesn't help with the custom runner directly because it would still run all the other PRs, heh)foo" },
    { "jschievink", R"foo(yeah, that's basically what I'm relying on right now)foo" },
    { "dirbaio[m]", R"foo(also, no websockets, just http long polling. And lots of POSTs to upload logs ü§Ø)foo" },
    { "dirbaio[m]", R"foo(it doesn't seem THAT bad though)foo" },
    { "dirbaio[m]", R"foo(it seems feasible to me to implement some subset that supports only `run` steps)foo" },
    { "dirbaio[m]", R"foo(enforcing non-privileged container per job)foo" },
    { "agg", R"foo(a non-priv container... that can still access the HIL you have attached?)foo" },
    { "agg", R"foo(I guess maybe you could add a list of users allowed to trigger jobs and just not run any from unknown users?)foo" },
    { "dirbaio[m]", R"foo(I think you can mount just one usb device)foo" },
    { "agg", R"foo(e.g. allow all repo/org members to run jobs right away, somehow require approval for others? idk)foo" },
    { "agg", R"foo(at this point it might be easier to just build a webhook that receives comments/prs from github api and then fetches the relevant code, the downside is not getting to use github yaml actions)foo" },
    { "agg", R"foo(but if you're writing your own runner anyway.....)foo" },
    { "agg", R"foo((e.g. your own self hosted bors, but it does hil testing))foo" },
    { "dirbaio[m]", R"foo(yeah reimplementing a runner is probably stupid)foo" },
    { "dirbaio[m]", R"foo(he nice thing is it'd reuse the GHA UI)foo" },
    { "dirbaio[m]", R"foo(otherwise you'd have to have some UI so users can see the logs)foo" },
    { "agg", R"foo(yea, true)foo" },
    { "dirbaio[m]", R"foo(but at that point installing something like drone is maybe easier)foo" },
    { "agg", R"foo(hmm)foo" },
    { "agg", R"foo(or gitlab I guess)foo" },
    { "agg", R"foo(you could probably set up gitlab to run only approved PRs from github, but make the logs public)foo" },
    { "dirbaio[m]", R"foo(external ci is not available on gitlab free anymore)foo" },
    { "agg", R"foo(ah)foo" },
    { "agg", R"foo(i guess you could DIY that part with a script that gets github api events and triggers gitlab api events, but meh)foo" },
    { "dirbaio[m]", R"foo(meh indeed)foo" },
    { "dirbaio[m]", R"foo(and they switched drone to a freemium license where the OSS version is very restricted :P)foo" },
    { "agg", R"foo(of course)foo" },
    { "agg", R"foo(gotta get that big corp megabucks I guess)foo" },
    { "dirbaio[m]", R"foo(yep everyone's trying to extract money like crazy from CI stuff)foo" },
    { "agg", R"foo(I can only assume someone's paying for i)foo" },
    { "dirbaio[m]", R"foo(you could say even github itself doesn't want their selfhosted runner to be "too good" so they can sell you more actions minutes)foo" },
    { "agg", R"foo(at least they'll sell you them by the minute I guess)foo" },
    { "agg", R"foo(Travis...)foo" },
    { "dirbaio[m]", R"foo(you're compiling the C code to a .a then linking everything from Rust?)foo" },
    { "dirbaio[m]", R"foo(you're probably missing linking with a libc)foo" },
    { "i_am_the_carl[m]", R"foo(That would make sense... hold on I think the cc crate had something for that.)foo" },
    { "i_am_the_carl[m]", R"foo(Hmm, I guess the CC crate didn't have that.)foo" },
    { "i_am_the_carl[m]", R"foo(Actually this may do the job.)foo" },
    { "i_am_the_carl[m]", R"foo(https://crates.io/crates/tinyrlibc)foo" },
    { "i_am_the_carl[m]", R"foo(In the end I couldn't get that working ether, but found a way to disable the feature in FreeRTOS that required the strlen function.)foo" },
    { "therealprof[m]", R"foo(The annoying part of GHA is really the completely lackluster documentation, I don't even want to know how many hours we burned to figure out how it works.)foo" },
    { "korken89[m]", R"foo(The trait is only used to do weird pointer stuff in the background)foo" },
    { "korken89[m]", R"foo(And there are 2 cases that need to be handled, slices and non-slices in this case...)foo" },
    { "chrysn[m]", R"foo(i *think* you can use any's downcast functionality even when you're not in a `dyn Any` situation)foo" },
    { "korken89[m]", R"foo(Can it detect slices?)foo" },
    { "korken89[m]", R"foo(I think you need if statements for each slice type then)foo" },
    { "chrysn[m]", R"foo(oh so you mean any kind of slice ... that sounds harder)foo" },
    { "Lumpio-", R"foo(Aren't all the Any functions implemented for dyn Any only tho)foo" },
    { "korken89[m]", R"foo(I sort of would have expected this to work)foo" },
    { "korken89[m]", R"foo(https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0924d9c3bfab41d9f3f0d7ac5a3cd058)foo" },
    { "chrysn[m]", R"foo(you're right, they're just implemented for `dyn Any`; however, when a function is generic, a locally created dynamically typed thing might be optimzied out right away.)foo" },
    { "korken89[m]", R"foo(Oh it was a small error)foo" },
    { "korken89[m]", R"foo(This worked: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=71bead2df403c018c26dd24e4bcec1ef)foo" },
    { "korken89[m]", R"foo(:D)foo" },
    { "chrysn[m]", R"foo(yay :-))foo" },
    { "korken89[m]", R"foo(I was 100% sure this would require specialization)foo" },
    { "chrysn[m]", R"foo(probably it's only specialization if there's any chance something might fit both (and [T] and &T are mutually exclusive))foo" },
    { "korken89[m]", R"foo(Seems so)foo" },
    { "korken89[m]", R"foo(Hmm, turned out to get a unified interface though was difficul)foo" },
    { "korken89[m]", R"foo(`print_is_slice(&a)` and `print_is_slice(&b)`)foo" },
    { "korken89[m]", R"foo(One now needs to do `print_is_slice(&a)` and `print_is_slice(b)`)foo" },
    { "korken89[m]", R"foo(And changing one of the impls to add/remove `&` in the type causes the implementations to collide)foo" },
    { "chrysn[m]", R"foo(maybe you can have a default implementation in the trait (that says "is-slice = no", and then have one implementation `for T where T: IsActuallySlice` that overrides it to say is-slice = yes?)foo" },
    { "korken89[m]", R"foo(Hmm)foo" },
    { "korken89[m]", R"foo(Could you make an example? I am not quite following)foo" },
    { "chrysn[m]", R"foo(just on i)foo" },
    { "korken89[m]", R"foo(Thanks! :D)foo" },
    { "dirbaio[m]", R"foo(without specialization? O_o)foo" },
    { "korken89[m]", R"foo(Indeed)foo" },
    { "korken89[m]", R"foo(I want it on stable :))foo" },
    { "korken89[m]", R"foo(Else I need to solve it via a proc-macro)foo" },
    { "korken89[m]", R"foo(And that will suck :P)foo" },
    { "dirbaio[m]", R"foo(not sure that's possible)foo" },
    { "korken89[m]", R"foo(We are trying to get printing of slices to work in `dwarffmt`)foo" },
    { "korken89[m]", R"foo(And either I do it via a trait, or via the proc-macro that parses the formating string, and then we need a marker for slices instead)foo" },
    { "chrysn[m]", R"foo(hmpf, no -- that boils down to just the same issue :-()foo" },
    { "dirbaio[m]", R"foo(I don't get why does the code you linked even work)foo" },
    { "korken89[m]", R"foo(Magic ü™Ñ)foo" },
    { "dirbaio[m]", R"foo(why does it with work with `for &T` but not with `for T`)foo" },
    { "chrysn[m]", R"foo(rying again with the &dyn Any approach...)foo" },
    { "korken89[m]", R"foo(I have no idea haha)foo" },
    { "korken89[m]", R"foo(But it does work :D)foo" },
    { "korken89[m]", R"foo(How far away is specialization now again? üòÖ)foo" },
    { "dirbaio[m]", R"foo(aaaah)foo" },
    { "dirbaio[m]", R"foo(it's implicitly T: Sized)foo" },
    { "korken89[m]", R"foo(N+1 years, where N is any integer?)foo" },
    { "dirbaio[m]", R"foo(and [T] is not Sized, so the impls don't overlap)foo" },
    { "korken89[m]", R"foo(Oh)foo" },
    { "korken89[m]", R"foo(Sneaky)foo" },
    { "chrysn[m]", R"foo(i mean there's always this hack: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=71bead2df403c018c26dd24e4bcec1ef)foo" },
    { "chrysn[m]", R"foo(is this about debugging (evaluating ELF files with DWARF) or about a very small formatter?)foo" },
    { "korken89[m]", R"foo(very small formatter using DWARF)foo" },
    { "korken89[m]", R"foo(Think defm)foo" },
    { "korken89[m]", R"foo(But DWARF based)foo" },
    { "chrysn[m]", R"foo(ah ... but then it's about the (non-embedded) expansion step?)foo" },
    { "korken89[m]", R"foo(Ah no, we need to detect when performing the print on the MCU if it is a slice)foo" },
    { "korken89[m]", R"foo(So we send the entire slice and not just the ptr and len)foo" },
    { "korken89[m]", R"foo(And I can do it via the proc macro)foo" },
    { "korken89[m]", R"foo(Like `log("Hello {:s}", &my_slice)`)foo" },
    { "korken89[m]", R"foo(Where `:s` indicates a slice)foo" },
    { "korken89[m]", R"foo(And generate special code for i)foo" },
    { "korken89[m]", R"foo(But I'd like to not do that if possible)foo" },
    { "dirbaio[m]", R"foo(what about slices in struct fields?)foo" },
    { "dirbaio[m]", R"foo(how'd you do that without a derive?)foo" },
    { "chrysn[m]", R"foo(understandable. (and btw, that'd be great to use, i just implemented a terrible remote log viewer via CoAP, and i'd like to do it right and this sounds like the way to go))foo" },
    { "korken89[m]", R"foo(For that one would need a derive)foo" },
    { "korken89[m]", R"foo(The idea of `dwarffmt` is not to replace `defmt`)foo" },
    { "korken89[m]", R"foo(They have different usecases)foo" },
    { "korken89[m]", R"foo(Preferable one would have both)foo" },
    { "korken89[m]", R"foo(If you don't have special derives, fall back to `dwarffmt`)foo" },
    { "chrysn[m]", R"foo(did you check the last link? maybe that's already good enough if the compiler is smart (it's a crude hack, though -- and works))foo" },
    { "korken89[m]", R"foo(Which allows you to print types you do not own for example)foo" },
    { "korken89[m]", R"foo(The worst thing I know is to print something I first need to vendor the lib)foo" },
    { "korken89[m]", R"foo(Add defmt or whatever)foo" },
    { "korken89[m]", R"foo(Use tha)foo" },
    { "korken89[m]", R"foo(Then it works, remove it all)foo" },
    { "korken89[m]", R"foo(Then it breaks again)foo" },
    { "korken89[m]", R"foo(Vendor again)foo" },
    { "korken89[m]", R"foo(....)foo" },
    { "korken89[m]", R"foo(Or I could just print utilizing DWARF)foo" },
    { "korken89[m]", R"foo(If GDB can print it, why not us?)foo" },
    { "dirbaio[m]", R"foo(ah yea, soooo annoying, did that with smoltcp)foo" },
    { "dirbaio[m]", R"foo(here's Debug2Format and Display2Format btw)foo" },
    { "dirbaio[m]", R"foo(you get the fmt strings bloat but maybe for dev it's OK)foo" },
    { "chrysn[m]", R"foo(next iteration: working general-but-ugly recognition, plus working sane-but-type-specific recognition in https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2563f12a39c023e1c06eaf1e6cdb1e9a)foo" },
    { "korken89[m]", R"foo(Cool)foo" },
    { "dirbaio[m]", R"foo(string ops on type_name ü§Ø)foo" },
    { "korken89[m]", R"foo(Haha)foo" },
    { "korken89[m]", R"foo(Brb lunch here now :))foo" },
    { "chrysn[m]", R"foo(for the third and final stage i'm trying to pull in the IsSlice trait, now that it works with concrete types)foo" },
    { "dirbaio[m]", R"foo(it's deliciously horrifying üëå)foo" },
    { "korken89[m]", R"foo(I'll see what you come up with!)foo" },
    { "korken89[m]", R"foo(Worst case it do it in the proc-macro and away specialization :))foo" },
    { "korken89[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party Worst case it do it in the proc-macro and await specialization :))foo" },
    { "chrysn[m]", R"foo(mh, i'm afraid, no luck :-()foo" },
    { "chrysn[m]", R"foo(documenting roads that didn't work out: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9d5c7d28697b4e620c73ddff2eaafff4)foo" },
    { "chrysn[m]", R"foo(all boils down to needing specialization.)foo" },
    { "korken89[m]", R"foo()foo" },
    { "korken89[m]", R"foo()foo" },
    { "korken89[m]", R"foo(Thanks for testing!)foo" },
    { "wucke13[m]", R"foo(Is there any convenient way to create null terminated static string literals in `no_std`?)foo" },
    { "jschievink", R"foo(https://docs.rs/cstr/0.2.8/cstr/ works fairly well for this)foo" },
    { "wucke13[m]", R"foo(But then I would always have to write ` CString::new("data data data data").unwrap()`, correct?)foo" },
    { "jschievink", R"foo(`cstr!` expands to a `&CStr`)foo" },
    { "jschievink", R"foo(so I don't think you'd have to do tha)foo" },
    { "chrysn[m]", R"foo(and especially, `cstr!` makes sure the null is there from the beginning and can be used from static memory)foo" },
    { "chrysn[m]", R"foo((so `cstr!("foo")` expands to something like `wrapper("foo0")`.))foo" },
    { "jschievink", R"foo(looks like no)foo" },
    { "jschievink", R"foo(right, the entire `CStr` / `CString` stuff is libstd-only)foo" },
    { "wucke13[m]", R"foo(Hmmh, that's kind of a bummer. Wouldn't it have made sense to include at least a literal type for this? Something like `b0"Some string which will be null terminated"`?)foo" },
    { "wucke13[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party Hmmh, that's kind of a bummer. Wouldn't it have made sense to include at least a literal type for this? Something like `b0"Some string which will be null terminated"`? But then again one could also type `b"Something something0"`, I see.)foo" },
    { "jschievink", R"foo(do you just want a `&str` that's null-terminated?)foo" },
    { "chrysn[m]", R"foo(are you sure? i'm using a local copy for legacy reasons, but that's no_std)foo" },
    { "jschievink", R"foo(it expands to `::std` paths)foo" },
    { "chrysn[m]", R"foo(hmpf, right, it i copied it out of std to get it no_std :-/)foo" },
    { "chrysn[m]", R"foo(https://docs.rs/cstr_core/0.2.2/cstr_core/)foo" },
    { "chrysn[m]", R"foo(it doesn't have a `cstr!()` macro, though (yet? https://github.com/Amanieu/cstr_core/issues/18))foo" },
    { "chrysn[m]", R"foo(the advantage `cstr!("foo")` over `b"foo0" is that there is type-level information on the presence of the trailing zero, so a function that passes it on to C can use it safely without an extra check for whether there's a 0 before the end of the [u8].)foo" },
    { "thalesfragoso[m]", R"foo(how can I create an array with a const generic size if the element doesn't implement copy ? it seems like `Default::default()` doesn't work)foo" },
    { "dirbaio[m]", R"foo(Stick the element in a cons)foo" },
    { "thalesfragoso[m]", R"foo(and if I can't make the new const ?)foo" },
    { "dirbaio[m]", R"foo(Then you can't i think...)foo" },
    { "dirbaio[m]", R"foo(You can initialize item by item with MaybeUninit lol)foo" },
    { "thalesfragoso[m]", R"foo(Damn, that is just to not use a constant size of 3 for the alarm state, since some timers will only have 1)foo" },
    { "thalesfragoso[m]", R"foo(I'm inclined to just always create 3)foo" },
    { "thalesfragoso[m]", R"foo(and return None in the get_alarm methods)foo" },
    { "dirbaio[m]", R"foo(Why can't alarm new be const?)foo" },
    { "thalesfragoso[m]", R"foo(function pointers)foo" },
    { "thalesfragoso[m]", R"foo(hmm, maybe there is a nightly feature for tha)foo" },
    { "dirbaio[m]", R"foo(even if none?)foo" },
    { "thalesfragoso[m]", R"foo(yep, but I found the feature)foo" },
    { "dirbaio[m]", R"foo(huh)foo" },
    { "thalesfragoso[m]", R"foo(const_fn_fn_ptr_basics)foo" },
    { "dirbaio[m]", R"foo(alternatively transmute to/from usize lolol)foo" },
    { "thalesfragoso[m]", R"foo(do you think it's worth it ? the users will need to specify the number of alarms in the type)foo" },
    { "dirbaio[m]", R"foo(probably not haha, was half-joking)foo" },
    { "dirbaio[m]", R"foo(just use moar nightly features)foo" },
    { "thalesfragoso[m]", R"foo(I mean even with the feature)foo" },
    { "dirbaio[m]", R"foo(ah, hmm)foo" },
    { "thalesfragoso[m]", R"foo(he users will have to place a 3 or a 1 in the type depending on the timer)foo" },
    { "dirbaio[m]", R"foo(can't it be an associated const of the Instance trait? so it picks the right one)foo" },
    { "dirbaio[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party can't it be an associated const of the Instance trait? so it picks the right one automatically)foo" },
    { "thalesfragoso[m]", R"foo(first I tried with the associate constant, but it can't be placed as an array size)foo" },
    { "thalesfragoso[m]", R"foo(array sizes get resolved before that, so it doesn't recognize i)foo" },
    { "dirbaio[m]", R"foo(wo)foo" },
    { "thalesfragoso[m]", R"foo(hat's why you need const generics....)foo" },
    { "thalesfragoso[m]", R"foo(otherwise generic_array would be completely differen)foo" },
    { "dirbaio[m]", R"foo(hm but it's an associated cons)foo" },
    { "dirbaio[m]", R"foo()foo" },
    { "dirbaio[m]", R"foo(hmmmmmm)foo" },
    { "dirbaio[m]", R"foo(you can with MOAR nightly magic)foo" },
    { "dirbaio[m]", R"foo(https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=08988638d650b38f9b4eea2bdd8d06ee)foo" },
    { "dirbaio[m]", R"foo(but maybe that's too much?)foo" },
    { "thalesfragoso[m]", R"foo(maybe ? two more nightly features for that, should we ?)foo" },
    { "dirbaio[m]", R"foo(yeah but these are the "warning this is unfinished and may crash the compiler or eat your cat" ones)foo" },
    { "thalesfragoso[m]", R"foo(oh, yeah, I didn't know those ones also have the warning)foo" },
    { "thalesfragoso[m]", R"foo(ok, it's decided, it's gonna be 3 for everyone)foo" },
    { "dirbaio[m]", R"foo(maybe do .take_alarm(n) and panic at runtime if `n)foo" },
    { "thalesfragoso[m]", R"foo(I already return an Option)foo" },
    { "thalesfragoso[m]", R"foo(and do tha)foo" },
    { "dirbaio[m]", R"foo(it's somewhat better than giving an alarm that doesn't work at all to the user)foo" },
    { "dirbaio[m]", R"foo(ah okay, so the array will always have 3, but if the timer has only 1 then take of alarms 2,3 will always return none?)foo" },
    { "thalesfragoso[m]", R"foo(yep)foo" },
    { "dirbaio[m]", R"foo(nais)foo" },
    { "dirbaio[m]", R"foo(just a tiny bit of wasted ram, can optimize later)foo" },
    { "dirbaio[m]", R"foo(üëçÔ∏è)foo" },
    { "amber[m]", R"foo(So I theoretically have CMSIS-DAP firmware installed on a WeAct blackpill)foo" },
    { "amber[m]", R"foo(But cargo flash says no probes detected ;()foo" },
    { "amber[m]", R"foo(one sec)foo" },
    { "amber[m]", R"foo(yeah)foo" },
    { "agg", R"foo(what operating system?)foo" },
    { "agg", R"foo(his is often just a driver issue)foo" },
    { "amber[m]", R"foo(linux)foo" },
    { "agg", R"foo(or permissions issue on linux)foo" },
    { "amber[m]", R"foo(hats what I considered)foo" },
    { "agg", R"foo(if you run `dmesg` does it say anything about the cmsis-dap at the end?)foo" },
    { "amber[m]", R"foo(I will check)foo" },
    { "amber[m]", R"foo(it does)foo" },
    { "agg", R"foo(create /etc/udev/rules.d/99-cmsis-dap.rules)foo" },
    { "agg", R"foo(write ATTRS{product}=="*CMSIS-DAP*", MODE="660", GROUP="plugdev", TAG+="uaccess")foo" },
    { "agg", R"foo(sudo udevadm control --reload)foo" },
    { "amber[m]", R"foo(okay thats progress)foo" },
    { "agg", R"foo(hat's a harder one to guess)foo" },
    { "agg", R"foo(could be a lot of things. likely candidates include: bad/wrong connection between probe and target, target not powered, target debug port disabled (maybe it's in sleep or firmware remapped the io pins or...))foo" },
    { "agg", R"foo(you should have gnd, swdio, and swclk connected between probe and target, and both probe and target should be powered)foo" },
    { "amber[m]", R"foo(I have it working know)foo" },
    { "amber[m]", R"foo(CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party I have it working now)foo" },
    { "amber[m]", R"foo(he weact stuff lead me astray)foo" },
    { "amber[m]", R"foo(Thank you for the help :D)foo" },
    { "agg", R"foo(nice!)foo" },
    { "agg", R"foo(no problem)foo" },
    { "amber[m]", R"foo(power stuff)foo" },
    { "amber[m]", R"foo(but I think its actually not working)foo" },
    { "amber[m]", R"foo(but only pretending to lmao)foo" },
    { "yatekii[m]", R"foo(haha)foo" },
    { "yatekii[m]", R"foo(how do you figure?)foo" },
    { "amber[m]", R"foo(well)foo" },
    { "amber[m]", R"foo(I just have a feeling I guess)foo" },
    { "amber[m]", R"foo(Right now is my break from programming so who knwos)foo" },
    { "yatekii[m]", R"foo(:D)foo" },
    { "gitlabhater", R"foo(That is this message meaning: „Äå422)foo" },
    { "gitlabhater", R"foo(The change you requested was rejected.)foo" },
    { "gitlabhater", R"foo(Make sure you have access to the thing you tried to change.)foo" },
    { "gitlabhater", R"foo(Please contact your GitLab administrator if you think this is a mistake.„Äç)foo" },
    { "gitlabhater", R"foo(I don't understand... I just try to login with root account.)foo" },
    { "gitlabhater", R"foo(„ÄêThe change you requested was rejected.„Äë‚Üê It mean Change Password web page ??¬† I (root) have no right to access this page !??)foo" },
    { "gitlabhater", R"foo(WHY This Stupid App have So Many Bugsssssss... ?¬† Lots bugs had meet long time ago.)foo" },
    { "adhoc", R"foo(it is big and complex?)foo" },
    { "binux", R"foo(Is there a tool or way to migrate a gitlab project including PRs and feature branches to github?)foo" },
    { "DJ-ArcAngel", R"foo(doesn't github have same import features as gitlab, because then it's build in)foo" },
    { "binux", R"foo(DJ-ArcAngel: I couldnt find one)foo" },
    { "luc4", R"foo(Hello! For unknown reasons, I found out that my GitLab db is corrupted in its schema. What could be a good way to import all data into a fresh db? Import/export of each project? Or is there a better (quicker) alternative?)foo" },
    { "Underknowledge", R"foo(@luc4 that depends on what you did to it. easyes always, restore a working backup)foo" },
    { "Underknowledge", R"foo(you ll find some help here https://docs.gitlab.com/ce/development/database_debugging.html and I remeber a thread in the forum)foo" },
    { "Underknowledge", R"foo(@gitlabhater try to delete your cookies, and just probably a PICNIC issue)foo" },
    { "luc4", R"foo(unfortunately the db broke in its schema, and I have no way to know when this happened. The result is that migrations sometimes fail. The broken db makes postgresql segfault. I already fixed the schema twice, now I guess it is time to give up. So I‚Äôd need to migrate my instance to a fresh db somehow, so that the schema is not broken anymore.)foo" },
    { "luc4", R"foo(I have backups, but it is very difficult to know when the mess happened, and may have happened months and months ago, without me noticing anything.)foo" },
    { "Underknowledge", R"foo(when you want to nulke the db and start a new one you can do ''' gitlab-rake db:drop db:create'''')foo" },
    { "luc4", R"foo(ok, but the would clear the content as well right?)foo" },
    { "Underknowledge", R"foo(followed by an gitlab-ctl reconfigure, should clean out the whole thing)foo" },
    { "luc4", R"foo(and then how could I reimport data?)foo" },
    { "luc4", R"foo(each project one by one?)foo" },
    { "luc4", R"foo(it‚Äôs the best I could find)foo" },
    { "Underknowledge", R"foo(hat should be in database_debugging, I only dropped the DB one time to get a backup back in. so youre there on your own sadly)foo" },
    { "luc4", R"foo(and what is the difference of recreating the db like that and creating a new instance from scratch?)foo" },
    { "Underknowledge", R"foo(well, I had a recent backup I just played back in. so I had then a working instance. When you good to start a new instance then just do that.)foo" },
    { "Unode", R"foo(Hi everyone, I have a .template that contains a needs: - target-One and a build stage that uses extends: .template but also defines a needs: - target-Two. Is there any way to have the build stage include both target-One and target-Two as needs: instead of overwriting the template? Currently the build ends up with needs: target-Two)foo" },
    { "Unode", R"foo(also, is there any service that can be used to see the final rendered gitlab-ci.yml file after all templating is logic is interpreted?)foo" },
    { "luc4", R"foo(Hello! Anyone who knows if a backup/restore procedure re-uses the database schema of the backup or if only database data are added to the new database?)foo" },
    { "ToM`", R"foo(I suppose you could check for any ¬´ CREATE TABLE ¬ª statements)foo" },
    { "luc4", R"foo(ToM`: in the backup you mean?)foo" },
    { "ToM`", R"foo(open .gitlab-ci.yml from the web UI ; there is a tab ¬´ View merged YAML ¬ª - a quite young feature, one or two releases old I think)foo" },
    { "ToM`", R"foo(yep)foo" },
    { "luc4", R"foo(ToM`: from what I see here https://copdips.com/2018/09/backup-and-restore-gitlab-in-docker.html#tar-version it seems the restore recreates the tables.)foo" },
    { "luc4", R"foo(ToM`: which is a problem for me... as the schema in the backup is broken...)foo" },
    { "ToM`", R"foo(I feel you... This is why I always keep several backups, and not the last one ^^ Been bit by i)foo" },
    { "luc4", R"foo(ToM`: I have many... the problem is that the database was probably broken many months ago :-()foo" },
    { "luc4", R"foo(ToM`: I didn't notice cause everything works properly until a migration occurs.)foo" },
    { "Unode", R"foo(ToM`: Thanks, found i)foo" },
    { "Unode", R"foo(Was already using the Web IDE but that feature was elsewhere. Cheers)foo" },
    { "Unode", R"foo(As for the extends I found a ticket in the meantime with discussion going back a few years on how this isn't possible so I'm exploring other options.)foo" },
    { "Unode", R"foo(hanks again everyone)foo" },
    { "luc4", R"foo(Anyone who knows if it is possible to use pg_dump on the internal gitlab database?)foo" },
    { "Human_G33k", R"foo(luc4, you can but it not the best wby)foo" },
    { "Human_G33k", R"foo(you should use the gitlab rake command to backup)foo" },
    { "luc4", R"foo(I'd need to use --data-only, can I do it with gitlab rake?)foo" },
    { "Human_G33k", R"foo(and you will need other things)foo" },
    { "Human_G33k", R"foo(like repositories dir, assets and configuration files with secrets.)foo" },
    { "luc4", R"foo(I do not want to backup and restore. I only need to recreate the db schema.)foo" },
    { "Human_G33k", R"foo(honestly never try, but a pg_dump work)foo" },
    { "Human_G33k", R"foo(so do not use --data-only)foo" },
    { "luc4", R"foo(I do not want the old schema, which is broken.)foo" },
    { "Human_G33k", R"foo(but more schema-only like)foo" },
    { "Human_G33k", R"foo(you can reply migration)foo" },
    { "luc4", R"foo(my current schema is broken, I only want to dump data.)foo" },
    { "Human_G33k", R"foo(*replay)foo" },
    { "luc4", R"foo(which migration?)foo" },
    { "Human_G33k", R"foo(database migration scrip)foo" },
    { "luc4", R"foo(I do not know when the schema broke.)foo" },
    { "Human_G33k", R"foo(but it depend on how your database is broke)foo" },
    { "luc4", R"foo(it is badly corrupted.)foo" },
    { "luc4", R"foo(by corrupted I mean that it is incoherent internally. I'd need a way to recreate the schema, and then reimporting only data.)foo" },
    { "Human_G33k", R"foo(i have the "same issue" on my own debian gitlab instance. WOrkinq on fix it.)foo" },
    { "Human_G33k", R"foo(so dump data only and try to insert on the new schema)foo" },
    { "luc4", R"foo(:-()foo" },
    { "luc4", R"foo(exactly)foo" },
    { "luc4", R"foo(hat is the solution, but I'm stuck dumping data-only.)foo" },
    { "Human_G33k", R"foo(from roo)foo" },
    { "Human_G33k", R"foo(su postgres)foo" },
    { "Human_G33k", R"foo(or no)foo" },
    { "Human_G33k", R"foo(you only have to know the database name)foo" },
    { "Human_G33k", R"foo(gitlab_production)foo" },
    { "luc4", R"foo(gitlabhq_production should be)foo" },
    { "Human_G33k", R"foo(from debian package)foo" },
    { "luc4", R"foo(I'm in docker, postgres does not exis)foo" },
    { "Human_G33k", R"foo(i hate sooo mutch docker)foo" },
    { "Human_G33k", R"foo(it s a dev tool not a production one ‚Ä¶)foo" },
    { "luc4", R"foo(pg_dump -h /var/opt/gitlab/postgresql/ -U gitlab-psql --column-inserts --data-only gitlabhq_production)foo" },
    { "luc4", R"foo(this may be near)foo" },
    { "luc4", R"foo(failed: FATAL: Peer authentication failed for user)foo" },
    { "Human_G33k", R"foo(easy)foo" },
    { "luc4", R"foo(maybe I'm missing some password...)foo" },
    { "Human_G33k", R"foo(you need to change conf in postgres conf)foo" },
    { "Human_G33k", R"foo(something in pg_hda.conf if i remember well)foo" },
    { "luc4", R"foo(oh, that I didn't know)foo" },
    { "luc4", R"foo(what should I change in there?)foo" },
    { "Human_G33k", R"foo(probably your ip or something is not se)foo" },
    { "Human_G33k", R"foo(and if there is a need for password it it can be the root cause too i guessx)foo" },
    { "Human_G33k", R"foo(not sure there is a password by defaul)foo" },
    { "Human_G33k", R"foo(more a unix socke)foo" },
    { "Human_G33k", R"foo(let me check)foo" },
    { "luc4", R"foo(unix socket is in /var/opt/gitlab/postgresql)foo" },
    { "luc4", R"foo(I'm not sure about the password)foo" },
    { "luc4", R"foo(couldn't find if there is a default one)foo" },
    { "Human_G33k", R"foo(for me conf is /etc/postgresql/13/main/pg_hba.conf you need to adapt it the conf dir and the version number.)foo" },
    { "Human_G33k", R"foo(a line containing local all all peer)foo" },
    { "luc4", R"foo(mmh... nothing in there)foo" },
    { "Human_G33k", R"foo(can be change to)foo" },
    { "Human_G33k", R"foo(local all all trus)foo" },
    { "Human_G33k", R"foo(ry)foo" },
    { "luc4", R"foo(find did not find any file with that name)foo" },
    { "Human_G33k", R"foo(in /var/opt/gitlab/postgresql)foo" },
    { "Human_G33k", R"foo(its a conf so pretty sure it can be a more generic one (debian make things well))foo" },
    { "luc4", R"foo(oh, hba!)foo" },
    { "luc4", R"foo(found i)foo" },
    { "Human_G33k", R"foo(ry the change restart posgresql)foo" },
    { "Human_G33k", R"foo(and retry the dump)foo" },
    { "Human_G33k", R"foo(also check gitlab-rack sub command)foo" },
    { "luc4", R"foo(I'm trying, thanks!)foo" },
    { "Human_G33k", R"foo(here is lot of stuff)foo" },
    { "Human_G33k", R"foo(for check "repair" existing gitlab instance)foo" },
    { "luc4", R"foo(unfortunately nothing changed)foo" },
    { "Human_G33k", R"foo(check gitlab conf file the database password should be somewhere)foo" },
    { "luc4", R"foo(eh... cannot find where unfortunately)foo" },
    { "luc4", R"foo(it seems it was sufficient to log in with the gitlab-psql user)foo" },
    { "luc4", R"foo(in case this can be of help to you)foo" },
    { "devslash", R"foo(has anyone here taken the gitlab certified associate course offered by gitlab)foo" },
    { "RandomArcher", R"foo(Hello everyone, I'm getting a "Access denied" (cloudflare error) when visiting 'gitlab.com' any idea why it's happening?)foo" },
    { "devslash", R"foo(when you use a quick action like /spend isnt it supposed to add a label on the issue with the spend time)foo" },
    { "N3X15", R"foo(Is there a way to delete a user and their contributions through the API? Some prick is spamming my instance and has whitespace in their name, so I can't confirm the delete via typing in their name)foo" },
    { "certifiable", R"foo(https://docs.gitlab.com/ee/api/users.html#user-deletion)foo" },
    { "certifiable", R"foo(With hard_delete=)foo" },
    { "N3X15", R"foo(409)foo" },
    { "N3X15", R"foo(gitlab.exceptions.GitlabHttpError: 409: User cannot be removed while is the sole-owner of a group)foo" },
    { "N3X15", R"foo(Time to make a security email, I guess)foo" },
    { "N3X15", R"foo(Ended up being a problem with the Python library I'm using.)foo" },
    { "N3X15", R"foo(Apparently they didn't think of passing params to DELETEs)foo" },
    { "IOhannes", R"foo(what about the 13.8.2 release?)foo" },
    { "IOhannes", R"foo(i so hate it when packages appear in the apt-repositories and there is no changelog/announcemen)foo" },
    { "dreamer", R"foo(changelog is overrated. you'll find out the new bugs soon enough!)foo" },
    { "ikke", R"foo(gitlab already supports system hooks)foo" },
    { "whf", R"foo(from what i've read, the system hooks are only on "git"-events: pre-receive, post-receive, update.)foo" },
    { "whf", R"foo(https://docs.gitlab.com/ee/administration/server_hooks.html)foo" },
    { "bernard__", R"foo(never understood git events)foo" },
    { "queip", R"foo(it's a script that runs when ever something happens, like a commit happens)foo" },
    { "queip", R"foo(it can afair also decide to outout some message, or to stop given operation from proceeding)foo" },
    { "bernard__", R"foo(yeah that part is understandable)foo" },
    { "bernard__", R"foo(in regards to CI though.. git-ftp doesn't trigger hooks right?)foo" },
    { "bernard__", R"foo(hey trigger by using git pull git commit etcetera)foo" },
    { "bernard__", R"foo(right?)foo" },
    { "whf", R"foo(There are several, bernard__ more info is on https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks .. gitlab uses the three server-side hook that are listed at the end of that page.)foo" },
    { "TomyWork", R"foo(I'm trying to remove a kubernetes cluster from a group that i just added there and didn't use for anything. I now clicked on "Remove integration and resources" 2 times now and all that happens is it showing "Kubernetes cluster integration and resources are being removed." at the top. been waiting for 10 minutes now, which is a little excessive for removing nothing :))foo" },
    { "TomyWork", R"foo(can i see the progress or logs or something somewhere?)foo" },
    { "bernard__", R"foo(danke)foo" },
    { "TomyWork", R"foo(ok i found something in the sidekiq dashboard... gcp_cluster:clusters_cleanup_service_account queue has a Clusters::Cleanup::ServiceAccountWorker job that keeps running into a 403)foo" },
    { "TomyWork", R"foo(I'm not sure what it's trying to do)foo" },
    { "TomyWork", R"foo(according to "kubectl get --all-namespaces serviceaccounts", there's no service account created after the "gitlab" service account that I created about 1.5 hours ago)foo" },
    { "TomyWork", R"foo(hat's the one i gave to gitlab to use. is it trying to delete that?)foo" },
    { "bernard__", R"foo(hm access logs?)foo" },
    { "TomyWork", R"foo(i think it's trying to use the company proxy -_-)foo" },
    { "TomyWork", R"foo(and that gives me a 403 cause that doesnt have access to internal services for obvious reasons)foo" },
    { "TomyWork", R"foo(and it's completely ignoring no_proxy and NO_PROXY)foo" },
    { "TomyWork", R"foo(even if i put the fqdn in there, even if i add the por)foo" },
    { "TomyWork", R"foo(and yes, i reconfigured and restarted everything)foo" },
    { "TomyWork", R"foo(i even checked using procfs if the sidekiq process got the environment variables)foo" },
    { "TomyWork", R"foo(net::http, or whatever it uses to wrap that, is broken)foo" },
    { "zumba_addict", R"foo(Need help, we can't search a string with spaces. How do we do that?)foo" },
    { "zumba_addict", R"foo(wrapping it with double quotes didn't help)foo" },
    { "bernard__", R"foo(%20)foo" },
    { "bernard__", R"foo(jk)foo" },
    { "zumba_addict", R"foo(lol)foo" },
    { "zumba_addict", R"foo(so not possible?)foo" },
    { "bernard__", R"foo(never found gitlabs search function useful)foo" },
    { "zumba_addict", R"foo(from their wiki page -)foo" },
    { "zumba_addict", R"foo(i just found out many at work hates the search functionality)foo" },
    { "bernard__", R"foo(same)foo" },
    { "D0han", R"foo(use grep)foo" },
    { "D0han", R"foo(¬Ø_(„ÉÑ)_/¬Ø)foo" },
    { "bernard__", R"foo(yeah clone all projects and run grep)foo" },
    { "bernard__", R"foo(shouldn't take long)foo" },
    { "zumba_addict", R"foo(sed may be faster)foo" },
    { "zumba_addict", R"foo(but grep is righ)foo" },
    { "zumba_addict", R"foo(ah, it doesn't like CMakeLists.txt LICENSE README.md build cmake raw raw-all scripts src third-party wildcard even if they mentioned it in their wiki, LMAO)foo" },
    { "wooosaiiii", R"foo(Lets say I have Jenkinsfile in my git repo. Will jenkins start the build if there are no new changes in my git repo? Can we somehow override this so that the build is triggered anyway?)foo" },
    { "nkuttler", R"foo(what kind of project do you have?)foo" },
    { "nkuttler", R"foo(fwiw, check build triggers in the config)foo" },
    { "halkeye[m]", R"foo(You can always build it manually, but it won't randomly start building on its own unless manually built, or a push (assuming scm is attached to the build). You can use ^^ such as the cron trigger to trigger it however often you want.)foo" },
    { "rewilliams", R"foo(Hello, I am trying to get this Jenkinsfile to work but keep getting the following failure. "java.lang.IllegalStateException: withCredentials step must be called with a body")foo" },
    { "tang^", R"foo(yup)foo" },
    { "tang^", R"foo(withCredentials() { steps_using_your_creds })foo" },
    { "rewilliams", R"foo(This is what I have)foo" },
    { "rewilliams", R"foo(https://gist.github.com/rewilliams1/28a674fc74759b728e737fdd2c6b4f83)foo" },
    { "rewilliams", R"foo(It seems to be correc)foo" },
    { "tang^", R"foo(no, it isn't correc)foo" },
    { "halkeye[m]", R"foo(as tang^ said, its a block not a statement, you need to wrap the statements you want credentials to be available for, in a block withCredentials() { stuff here })foo" },
    { "tang^", R"foo(if you're trying to use API token in the ansiblePlaybook call, you need {} around that step)foo" },
    { "halkeye[m]", R"foo(also that looks like a segment of declarative, which doesn't support withCredentails like that. You either need script { withCredentials { foo } }, or to use credentials in your environment block)foo" },
    { "tang^", R"foo(oh, I missed that par)foo" },
    { "rewilliams", R"foo(It is a declarative pipeline)foo" },
    { "halkeye[m]", R"foo(https://www.jenkins.io/doc/book/pipeline/jenkinsfile/#handling-credentials)foo" },
    { "tang^", R"foo(okay, let me suggest an alternative then)foo" },
    { "tang^", R"foo(https://gist.github.com/kenrachynski/2b996675dd6c2d2335481df2bb05059a)foo" },
    { "rewilliams", R"foo(oh thats what halkeye[m] mean)foo" },
    { "tang^", R"foo(and the next revision uses the full declarative setup)foo" },
    { "tang^", R"foo(oh, cool, it shows your revisions too)foo" },
    { "rewilliams", R"foo(so does the script addition add a segment of scripted pipeline to declarative?)foo" },
    { "tang^", R"foo(yes)foo" },
    { "tang^", R"foo(if you look at version 4 of my gist, you can see how to do it without the script{} block)foo" },
    { "rewilliams", R"foo(cool, I didnt realize that this was the same as calling withCredentials credentials( 'AutoCreateAutoUpdateJobsToken' ))foo" },
    { "tang^", R"foo(yeah, halkeye[m]'s link shows the declarative path for using credentials)foo" },
    { "tang^", R"foo(he credential does need to be supported so there may be some types that still require steps{ withCredentials() {} })foo" },
    { "halkeye[m]", R"foo(most of the common ones are fine though)foo" },
    { "tang^", R"foo(yeah)foo" },
    { "tang^", R"foo(I don't think I've run into any that didn't work in the environment{} block)foo" },
    { "rewilliams", R"foo(Cool, thanks for showing both methods.)foo" },
    { "tang^", R"foo(no problem)foo" },
    { "tang^", R"foo(I find that helps me remember the differences)foo" },
    { "rewilliams", R"foo(I'm still a bit confused to why mine didnt work. When using withCredentials with "sh" it works like that just fine)foo" },
    { "rewilliams", R"foo(If you all don't mine given some insight around tha)foo" },
    { "tang^", R"foo(possibly you need to pass the credentials to the ansiblePlaybook task)foo" },
    { "tang^", R"foo(hey do get added to the env, but since you're using a plugin, it might not be looking in env)foo" },
    { "hichhiker", R"foo(from what I recall, at least in scripted - `withCredentials()` adds Groovy variables into the binding of it's closure, but does not create env variables by defaul)foo" },
    { "hichhiker", R"foo(hat may be a source of some confusion)foo" },
    { "tang^", R"foo(https://gist.github.com/kenrachynski/b2a953c3a7b01b13575ed133ef186c3b)foo" },
    { "tang^", R"foo(mind you, I use environment{} with my ansiblePlaybook calls successfully)foo" },
    { "tang^", R"foo(yeah but we want to keep it within declarative)foo" },
    { "tang^", R"foo((yes, I clicked on your link))foo" },
    { "hichhiker", R"foo(Yeah, this is pure scripted)foo" },
    { "rewilliams", R"foo(Okay so it looks like I can use both)foo" },
    { "tang^", R"foo(Jenkins is nothing if not flexible)foo" },
    { "rewilliams", R"foo(Very flexible but also difficult to get a hold of everything)foo" },
    { "tang^", R"foo(yeah)foo" },
    { "hichhiker", R"foo(sometimes there are too many options :-D)foo" },
    { "AlanMD", R"foo(Greetings. Any idea how to get past this problem https://issues.jenkins.io/browse/JENKINS-46468 ?)foo" },
    { "jenkins-admin", R"foo(JENKINS-46468:"no such computer" error occurs during SCM Pulling (Open) https://issues.jenkins.io/browse/JENKINS-46468)foo" },
    { "rewilliams", R"foo(Thanks all, so my initial problem was because the ansible plugin does not see variables in the environment? Just trying to report back to team with correct logic.)foo" },
    { "tang^", R"foo(not necessarily... I shared another gist of mine that I use in production right now... it uses environment variables, but isn't using the same one you're using)foo" },
    { "rewilliams", R"foo(The one you shared uses environment instead of script. I was going to use the script option and wanted to verify the logic behind that one)foo" },
    { "tang^", R"foo(I know that one works with environment because the SSH key is provided to ansiblePlaybook via environment and connects to my servers properly)foo" },
    { "rewilliams", R"foo(is your SSHKEY being used for your step credentialsId?)foo" },
    { "tang^", R"foo(yes)foo" },
    { "tang^", R"foo(agent{ label 'aws' } is an ephemeral EC2 agent... doesn't have the key before it starts up)foo" },
    { "rewilliams", R"foo(oh so it just makes it available)foo" },
    { "rewilliams", R"foo('jenkins-ansible-key')foo" },
    { "rewilliams", R"foo(Where is this variable coming from)foo" },
    { "tang^", R"foo(credentials as well)foo" },
    { "tang^", R"foo(hmm, wonder if that's overriding the environment one)foo" },
    { "tang^", R"foo(hat would be "fun")foo" },
    { "rewilliams", R"foo(lol)foo" },
    { "tang^", R"foo(let me check my credentials store for both of those)foo" },
    { "rewilliams", R"foo(so you don't have set it explicitly? I assumed that there needed to be an environment for that also)foo" },
    { "tang^", R"foo(okay, jenkins-ansible-key is a SSH Username with Private Key)foo" },
    { "tang^", R"foo(jenkins-ansible is a secret file)foo" },
    { "tang^", R"foo(which, I assume is just the private key)foo" },
    { "tang^", R"foo(dang it, now I have to review that job to see exactly how it's working)foo" },
    { "tang^", R"foo(he plugin's github project says it should be able to use any environment variables you configure)foo" },
    { "tang^", R"foo(so root cause for your issue was in not using the withCredentials block properly. you can either use withCredentials or environment blocks to get your data to the plugin)foo" },
    { "annette", R"foo(I have an issue with the jenkins ajent.jar 4.3 when configure behind a proxy server.¬† I am getting can't connect to jenkins server on 49187 and i Ma not seeing any traffic coming from my server. I am concerned that I have either not configured the startup correctly for the connection string or that tis release of the jar not longer supports)foo" },
    { "annette", R"foo(proxy.. It is important to note that this came config works correctly with agent.jar release 3.17¬† Any help would be much appreciated.)foo" },
    { "annette", R"foo(I am not seeing traffic...)foo" },
    { "koopajah", R"foo(rounding with tax is quite complex. We have a detailed section in the doc about this: https://stripe.com/docs/billing/taxes/tax-rates#rounding)foo" },
    { "koopajah", R"foo(do you have a concrete example I can look at?)foo" },
    { "koopajah", R"foo(I just tried locally in the Dashboard. Subscription to a Price for $14.98, quantity 2 and tax rate 9.5 and my invoice is for $32.81 which matches what you expected)foo" },
    { "koopajah", R"foo(here is fine if it's just an id, but you can DM me otherwise)foo" },
    { "koopajah", R"foo(blueco okay so you have 2 separate prices, not one price with quantity 2)foo" },
    { "koopajah", R"foo(and so it can lead to rounding discrepancies because of the way we "spread" the tax across items")foo" },
    { "koopajah", R"foo(yeah)foo" },
};
